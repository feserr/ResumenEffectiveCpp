\documentclass[10pt]{beamer}
\usepackage{etex}
\setbeamertemplate{navigation symbols}{}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\setcounter{tocdepth}{3}
\usepackage{color}
\usepackage{amsmath,comment,dcolumn,graphicx,letterspace,multicol,multirow}
\usepackage{arrayjob,multido,ifthen,moreverb}
\usepackage{pstricks,pst-plot,pst-node} % core PSTricks packages (loaded first)
\usepackage[normalem]{ulem}
\usepackage{multirow}
\usepackage{helvet}
\usepackage{fancybox}
\usepackage{tikz}
\usepackage{cases}
\usepackage{caption}
\usepackage{multimedia}
\usepackage{tabularx}

%% Code listing
\usepackage{listings}
\usepackage{courier}
\lstset{
  basicstyle=\footnotesize\ttfamily, % Standardschrift
  %numbers=left,               % Ort der Zeilennummern
  numberstyle=\tiny,          % Stil der Zeilennummern
  %stepnumber=2,               % Abstand zwischen den Zeilennummern
  numbersep=5pt,              % Abstand der Nummern zum Text
  tabsize=2,                  % Groesse von Tabs
  extendedchars=true,         %
  breaklines=true,            % Zeilen werden Umgebrochen
  keywordstyle=\color{red},
  %frame=b,
  %        keywordstyle=[1]\textbf,    % Stil der Keywords
  %        keywordstyle=[2]\textbf,    %
  %        keywordstyle=[3]\textbf,    %
  %        keywordstyle=[4]\textbf,   \sqrt{\sqrt{}} %
  stringstyle=\color{white}\ttfamily, % Farbe der String
  showspaces=false,           % Leerzeichen anzeigen ?
  showtabs=false,             % Tabs anzeigen ?
  xleftmargin=17pt,
  framexleftmargin=17pt,
  framexrightmargin=5pt,
  framexbottommargin=4pt,
  %backgroundcolor=\color{lightgray},
  showstringspaces=false      % Leerzeichen in Strings anzeigen ?
}
\lstloadlanguages{% Check Dokumentation for further languages ...
  %[Visual]Basic
  %Pascal
  %C
  C++
  %XML
  %HTML
  %Java
}

\usepackage{pgfpages}
%\setbeameroption{show notes}
%\setbeameroption{show notes on second screen=right}
%\hypersetup{pdfpagemode=FullScreen}

\usepackage{float}
\usepackage[format=hang,singlelinecheck=0,font={sf,small},labelfont=bf]{subfig}
\usepackage{caption}
\usepackage[noabbrev]{cleveref}

\captionsetup[subfigure]{subrefformat=simple,labelformat=simple,listofformat=subsimple}
\renewcommand\thesubfigure{(\alph{subfigure})}

\usepackage{subfig}

\usetikzlibrary{matrix, patterns}

\renewcommand<>{\emph}[1]{{\only#2{\em}#1}}

\graphicspath{{assets/}}

\newcolumntype{.}{D{.}{.}{-1}}
\DeclareMathOperator*{\argmax}{argmax}
\newcommand{\card}[1]{\ensuremath{\lvert{#1}\rvert}}
\renewcommand{\v}[1]{\mathbf{#1}}
\newcommand{\pstr}[4]{\rput[B](#1,#2){#3}\rput[B](#1,#2.8){#4}}

\definecolor{orange}{HTML}{FF7F00}
\definecolor{darkred}{HTML}{B40404}
\definecolor{darkgreen}{HTML}{31B404}
\definecolor{darkblue}{HTML}{0101DF}
\definecolor{tLp}{rgb}{.65,.17,.16}
\definecolor{tLs}{rgb}{.99,.30,.01}
\newcommand{\translectures}{%
  \textcolor{tLp}{\normalfont\sffamily trans}%
  \hspace*{.25mm}%
  \textcolor{tLs}{\bf\sffamily Lectures~}}
\newcommand{\tl}{\translectures}

\setbeamertemplate{frametitle}{
  \vspace{1em}
  \insertframetitle
}

\usetheme{CambridgeUS}
\usecolortheme{dolphin}
%\usetheme{JuanLesPins}

\makeatletter
\setbeamertemplate{footline}%{infolines theme}
{
  \leavevmode%
  \hbox{%
    \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,center]{author
        in head/foot}%
      \usebeamerfont{author in
        head/foot}\insertshortauthor\expandafter
    \end{beamercolorbox}%
    %\begin{beamercolorbox}[wd=.20\paperwidth,ht=2.25ex,dp=1ex,center]{title
    %in head/foot}%
    %	\usebeamerfont{title in head/foot}\insertshorttitle
    %\end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,right]{date
        in head/foot}%
      \usebeamerfont{date in
        head/foot}\insertshortinstitute {}\hspace*{2em}
      \insertframenumber{} -- \inserttotalframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatother

\setbeamertemplate{itemize items}[triangle]
\setbeamertemplate{enumerate items}[default]
\setbeamertemplate{sections/subsections in toc}[sections numbered]

\beamersetuncovermixins{\opaqueness<1>{25}}{\opaqueness<2->{15}}

\begin{document}
  \title[]{Resumen del libro Effective C++}
  \author[Elías Serrano]{
    \begin{tabular}{r@{ }l}
      \multicolumn{2}{c}{Elías Serrano}
    \end{tabular}
  }
  \institute[Resumen del libro Effective C++]

  \begin{frame}
  \titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[allowframebreaks]
\frametitle{Índice}
\tableofcontents[sections={1-2}]
\framebreak
\tableofcontents[sections={3}]
\framebreak
\tableofcontents[sections={4}]
\framebreak
\tableofcontents[sections={5-6}]
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Accustoming yourself to \texttt{C++}}

\subsection{Item 1: View C++ as a federation of languages.}
\label{sec:item1}
\begin{frame}
\frametitle{Item 1: View C++ as a federation of languages}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 2: Prefer consts, enums, and inlines to \#defines.}
\label{sec:item2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile,allowframebreaks]
\frametitle{Item 2: Prefer consts, enums, and inlines to \#defines.}
\begin{itemize}
  \item Los \textbf{defines} pueden no reflejarse jamas en el compilador, este
   uede generar múltiples instancias de él y que no lo encapsule.
  \item Los \textbf{define} no se pueden encapsular.

  \item Sobre \textbf{const}:
  \begin{itemize}
    \item Solo se hace una instancia de la variable.
    \item Si se quiere que sea única en la clase, hay que declararla
    \textbf{static}. Para ello será necesario definirlo, por ejemplo:

    \lstinputlisting{assets/listings/item2-1.cpp}
  \end{itemize}

  \framebreak

  \item Respecto a los \textbf{enum}
  \begin{itemize}
    \item Se hace uso del \textbf{enum hack} para definir variables, por
     ejemplo:

    \lstinputlisting{assets/listings/item2-2.cpp}

    \item Su uso es parecido al de \textbf{define}, pero con estos se puede
     obtener la dirección de memoria.
  \end{itemize}
  \item En cuanto a los \textbf{inline}
  \begin{itemize}
    \item Se usan para sustituir la creación de macros con \textbf{define}.
    \item El uso de \textbf{define} hace que no se controlen bien ciertas
     ejecuciones, dado que si se incrementa una variable de la macro, esta
     puede ocurrir en distintos casos. Por ejemplo:

    \lstinputlisting{assets/listings/item2-3.cpp}

    \item Con \textbf{inline} se permite la creación de macros privadas.
  \end{itemize}
  \item Para constantes simples, usar objetos \textbf{const} o \textbf{enums}
   en vez de \textbf{\#defines}.
  \item Para funciones tipo macros, usar \textbf{inline} en vez de
   \textsf{\#defines}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 3: Use const whenever possible}
\label{sec:item3}

\begin{frame}[fragile,allowframebreaks]
\frametitle{Item 3: Use const whenever possible}
\begin{itemize}
  \item Se verifican en tiempo de compilación.
  \item Afectan al tipo de su izquierda.

    \lstinputlisting{assets/listings/item3-1.cpp}

  \item \textbf{const\_iterator} es como \textbf{const T\*}. Se puede usar para
   que el valor que se devuelva no pueda ser modificado, por ejemplo en una
   operación.

  \item Se puede usar cuando se quiere devolver una variable constante o
   normal. Por lo que se crea la función que devuelve el valor constante y luego
   para devolverla en su forma normal, haremos que el
   método \textbf{non-const} sea el que llame al constante de la siguiente
   manera.

  \framebreak

  \lstinputlisting{assets/listings/item3-2.cpp}

  \framebreak

  \item Si se pone antes de las llaves en una función, entonces especificamos
   que esa definición sera constante y no se puede modificar nada en la
   declaración (\textbf{bitwise constness}), por lo que para modificar una
   variable en la misma, habremos de señalar que es \textbf{mutable}
   (\textbf{logical constness}).
  \item Usar \textbf{const} ayuda al compilador a detectar errores de uso.
   \textbf{const} se puede aplicar a cualquier tipo de objetos, parámetros de
   las funciones, tipos de retorno y al conjuntos de miembros de una función.
  \item Los compiladores fuerzan a aplicar \textbf{bitwise constness}, pero se
   debe programar usando \textbf{logical constness}.
  \item Cuando los miembros de una función son \textbf{const} y
   \textbf{non-const} tienen idéntica implementación, la duplicación de código
   puede ser evitada haciendo que la versión \textbf{non-const} llame a la
   versión \textbf{const}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 4: Make sure that objects are initialized before they are used}
\begin{frame}
\frametitle{Item 4: Make sure that objects are initialized before they are
used}
\label{sec:item4}
\begin{itemize}
  \item Hay que inicializar siempre las variables en el \textbf{constructor},
   tanto en los que aceptan parámetros como en los de por defecto.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Constructors, destructors and assigment operators}

\subsection{Item 5: Know what functions C++ silently writes and calls}
\label{sec:item5}
\begin{frame}
\frametitle{Item 5: Know what functions C++ silently writes and calls}
\begin{itemize}
  \item Cuando creas una clase, sino declaras el \textbf{constructor},
   \textbf{destructor}, \textbf{copy constructor} y
   \textbf{copy assigment operator} el compilador los creara \textbf{públicos}
   por ti.
  \item Las funciones \textbf{copy constructor} y \textbf{copy assigment
   operator} básicamente copiaran los elemento \textbf{no estáticos} de un
   objeto al otro. Pero esto solo lo hará cuando sea posible, es decir, si se
   intenta copiar un \textbf{std::string} usará el \textbf{copy constructor} o
   \textbf{copy assigment operator} de esta clase, ya que esta declarado, o en
   el caso de que sea un elemento simple (p.e int) copiara los bits de uno a
   otro. En el caso de que sea una variable que no se pueda, p.e una variable
   \textbf{const}, el compilador no generara automáticamente estos métodos.
  \item Es posible que el compilador genere implícitamente el
   \textbf{constructor}, \textbf{copy
constructor}, \textbf{copy assignment operator} y \textbf{destructor}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 6: Explicitly disallow the use of compiler generated functions
you do not want}
\label{sec:item6}

\begin{frame}
\frametitle{Item 6: Explicitly disallow the use of compiler generated functions
you do not want}
\begin{itemize}
  \item Si no queremos que se hagan copias de nuestros objetos, debemos
   declarar los métodos
   \textbf{copy constructor} y \textbf{copy assigment operator} privados, de
   este modo el error saldrá
   en la fase de enlace.
  \item Si queremos hacer que el error sea en compilación, deberemos crear una
   clase como la siguiente.

  \begin{minipage}{\linewidth}
  \lstinputlisting{assets/listings/item6-1.cpp}
  \end{minipage}
   De este modo, el objeto que no queramos que sea copiado, haremos que herede
   de forma privada
   del objeto anterior.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 7: Declare destructors virtual in polymorphic base classes}
\label{sec:item7}

\begin{frame}[fragile,allowframebreaks]
\frametitle{Item 7: Declare destructors virtual in polymorphic base classes}
\begin{itemize}
  \item Si una clase base no declara virtual su destructor, cuando el objeto
   que herede de este e intente eliminarlo solo eliminara la memoria de la
   clase padre y no del objeto hijo.
  \item Si una clase no tiene ninguna función virtual no esta
   orientada a ser una clase base o padre. Por lo tanto, su destructor
   no tiene que ser virtual. Se deben obviar el uso de virtual ya que genera
   información extra, por ejemplo en la siguiente clase.

  \lstinputlisting{assets/listings/item7-1.cpp}

  \framebreak

  \item Si un int ocupa 32 bit, esta clase cabrá en un registro de 64 bits. En
   el caso de implementar alguna función \textbf{virtual} se requiere que
   el objeto lleve información de que objeto se lanza la función
   \textbf{virtual}. Esta información toma la forma de un puntero llamado
   \texttt{vptr} (''virtual table pointer''). Este apunta a una array de
   punteros a funciones llamado \texttt{vtbl} (''virtual table''); cada
   clase con funciones virtuales tiene asociada una \texttt{vtbl}. En el
   caso de que nuestra clase Point tuviese una función virtual ocuparía 64
   bits por los dos enteros mas la mitad de dicha suma, en total unos 96
   bits. Se estaría perdiendo memoria.
  \item Hay que tener cuidado con heredar de clases de la \textbf{STL},
   \textbf{string} o todos los tipos de
   contenedores. Estos no tienen declarado el \textbf{destructor} de forma
   \textbf{virtual}.
  \item Si quieres crear una clase base como abstracta pero no tienes ninguna
   función virtual pura, la solución es crear su \textbf{destructor} como
   \textbf{virtual puro}. De este modo sera abstracta y no nos
   tendremos que preocupar por problemas al destruirla. La única desventaja es
   que debemos definir el destructor en todos los hijos.
  \item Solo las clases bases que vayan a ser poliformicas se les puede aplicar
   la regla del \textbf{destructor virtual}. Aun así, si una clase tiene una
   función \textbf{virtual} su \textbf{destructor} ha de serlo también.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 8: Prevent exceptions from leaving destructors}
\label{sec:item8}

\begin{frame}
\frametitle{Item 8: Prevent exceptions from leaving destructors}
\begin{itemize}
  \item En un \textbf{destructor} no pueden haber llamadas que generen
   excepciones. Dependiendo de que tipo sea, puede abortar el programa o dar
   un comportamiento indefinido y dejar memoria por liberar (corrupta).
  \item Se puede solucionar usando \texttt{try} y \texttt{catch} parando la
   ejecución cuando salta una excepción o continuar, dejando memoria por
   liberar, y avisar al programador.
  \item Una manera de solucionarlo es crear un método que libere la memoria y
   en el \textbf{destructor} comprobar que si no esta liberada usar lo
   expuesto en el punto anterior. No es una manera muy elegante de
   solucionarlo, ya que dejas la responsabilidad al programador, pero le das la
   oportunidad de que trate los errores a que no tengan oportunidad de
   reaccionar a los mismos.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 9: Never call virtual functions during construction or
destruction}
\label{sec:item9}

\begin{frame}
\frametitle{Item 9: Never call virtual functions during construction or
destruction}
\begin{itemize}
  \item Si creamos una clase base que el \textbf{constructor} o
   \textbf{destructor} llaman a una función virtual para modificar unas
   variables, cuando un objeto herede de
   esta dará comportamientos inesperados. El problema radica en que cuando un
   objeto que hereda de otro se construye o se destruye primero llama a los
   métodos de la clase base y luego a los derivados, esto es porque antes de
   llamar a sus métodos derivados, el objeto es tratado como si fuese de la
   clase base, nada del objeto derivado existe. Por lo tanto, si llama a los
   métodos virtuales, por mucho que los redeclaremos en el derivado, el
   seguirá llamando a los de la clase base, y esto hará que las variables
   modificadas se queden como \textbf{undefined}.
  \item Esto también pasa si el constructor de la clase base llama a un método
   que a su vez este llama a un método virtual. Con esto conseguimos engañar
   al compilador para que no nos pueda avisar en  la fase de compilación.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 10: Have assignment operators return a reference to *this}
\label{sec:item10}

\begin{frame}
\frametitle{Item 10: Have assignment operators return a reference to *this}
\begin{itemize}
  \item Las asignaciones en C++ pueden encadenarse.

   \begin{minipage}{\linewidth}
   x = y = z = 15;
   \end{minipage}

   También hay que decir que son \textbf{right-associative}, por lo tanto:

   \begin{minipage}{\linewidth}
   (x = (y = (z = 15)));
   \end{minipage}

   En este ejemplo el resultado de \texttt{z} se devuelve y lo coge \texttt{y}
   que a su vez lo devuelve y lo obtiene \texttt{x}

  \item Para conseguir esto debemos devolver \textbf{*this} siempre que
   declaremos o sobrescribamos métodos de asignación.

   \lstinputlisting{assets/listings/item10-1.cpp}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 11: Handle assignment to self in operator=}
\label{sec:item11}

\begin{frame}[fragile,allowframebreaks]
\frametitle{Item 11: Handle assignment to self in operator=}
\begin{itemize}
  \item Es probable que sin darnos cuentas hagamos un \textbf{self assigment},
   por ejemplo:

  \lstinputlisting{assets/listings/item11-1.cpp}

  \framebreak

  \begin{itemize}
    \item Ejemplo 1: Vemos como claramente asignamos el mismo objeto a si
      mismo.
    \item Ejemplo 2: En el caso de que i y j apunten al mismo objeto se causara
      un \textbf{self assigment}.
    \item Ejemplo 3: En temas de herencia, podemos tener que una referencia o
      puntero del objeto base sea el mismo que el del objeto derivado.
  \end{itemize}

  \framebreak

  \item Esto pasa si nuestro método de asignación es del siguiente modo:

  \lstinputlisting{assets/listings/item11-2.cpp}

  \framebreak

  \item En el caso de que estemos usando esto con el mismo objeto, cuando
   eliminamos el \texttt{bitmap} actual también eliminamos el otro, dado que es
   el mismo. Una solución seria:

  \lstinputlisting{assets/listings/item11-3.cpp}

  \item El problema de esta solución es que es \texttt{exception-unsafe}. Puede
   que el nuevo \texttt{bitmap} contenga una excepción (porque no queda memoria
   o porque el constructor lance una), en este caso apuntará a un objeto
   eliminado (\textbf{dangling pointer}).

  \framebreak

  \item Si queremos solucionar el problema de \textbf{self assigment} y
   \texttt{exception-unsafe} deberemos guardamos una copia del objeto
   original, cambiarlo por el nuevo objeto y eliminar la copia. También
   podríamos proceder construyendo un objeto temporal con el objeto nuevo y
   luego intercambiarlo con el original. Podemos ver la solución en el
   siguiente ejemplo.

  \framebreak

  \lstinputlisting{assets/listings/item11-4.cpp}

  \framebreak

  \item El segundo ejemplo hace lo mismo que el primero pero construye la copia
   en el parámetro al ser pasado por valor. Este método puede ser mejor dado que
   los compiladores a veces generan código mejor optimizado.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 12: Copy all parts of an object}
\label{sec:item12}

\begin{frame}
\frametitle{Item 12: Copy all parts of an object}
\begin{itemize}
  \item Cuando sobrecargamos la función de \textbf{copy assignment} tenemos que
   acordarnos de copiar todos las variables y objetos al nuevo.
  \item Es fácil olvidarnos de copiarlo todo cuando la clase es hija de otra.
   En este caso debemos llamar a la función de \textbf{copy assignment} de la
   clase padre, porque sino no estaremos copiando todos los elementos, por el
   hecho de que cuando nuestra clase es hija de otra, esta también es una clase
   padre por dentro.
  \item Al copiar los datos de las variables que son objetos y de la clase
   padre hay que hacerlo usando la funciones de copia apropiadas.
  \item Cuando el comportamiento del \textbf{copy constructor} y \textbf{copy
   assignment} es igual es mejor crear una tercera función que sea llamada por
   los dos.
  \item Hay que tener especial cuidado con no llamar al \textbf{copy
   constructor} en el \textbf{copy assignment} y viceversa si no queremos que la
   memoria se corrompa o surjan comportamientos extraños.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Resource management}

\subsection{Item 13: Use objects to manage resource}
\label{sec:item13}

\begin{frame}
\frametitle{Item 13: Use objects to manage resource}
\begin{itemize}
  \item Cuando creamos un objeto dinámico siempre ha de ser eliminado antes de
   que el programa se cierre si no queremos dejar memoria corrupta.
  \item En el caso de crear un objeto en una función y eliminarla al final
   puede crear muchos problemas. En un principio estamos eliminando el objeto
   que hemos creado, pero solo cuando ha llegado al final de la misma. Si se
   activase un retorno antes estariamos dejando memoria por liberar. También
   puede ocurrir si creamos y eliminamos objetos dentro de un bucle y en este
   hay \textbf{break} y \textbf{goto}. No hay que olvidarse de funciones que
   pueden lanzar excepciones.
  \item Para ello existe \textbf{auto\_ptr} y \textbf{shared\_ptr}. Estos dos
   objetos de la STL se encargan de liberar la memoria cuando el programa a
   terminado, están fuera del alcance, y en los casos descritos anteriormente.
   Eso si, estos objetos llaman a \textbf{delete} para liberar su memoria, por
   lo que no son candidatos de ser usados en \textbf{arrays}.
  \item Algo positivo de \textbf{auto\_ptr} y \textbf{shared\_ptr} es que
   siguen la política RAII y que siempre serán eliminados no importa el
   comportamiento que tenga el programa.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 14: Think carefully about copying behavior in
resource-managing classes}
\label{sec:item14}

\begin{frame}[allowframebreaks]
\frametitle{Item 14: Think carefully about copying behavior in
resource-managing classes}
\begin{itemize}
  \item No los recursos se generan dinámicamente, y para ellos usar
   \textbf{auto\_ptr} o \textbf{shared\_ptr} no sirven, por lo que tendrás que
   crear uno propio.
  \item Si, por ejemplo, queremos uno que manipule objetos del tipo
   \textbf{Mutex} que ofrecen la función \textbf{lock} y \textbf{unlock}:
\end{itemize}

\lstinputlisting{assets/listings/item14-1.cpp}

\framebreak

\begin{itemize}
  \item En el caso de usar este objeto, cuando se salga del alcance de la
   función, se desbloqueará automáticamente por el hecho de que su destructor
   hace eso.
  \item El problema que puede crear es si copiamos el objeto a otro nuevo, si
   uno se destruye desbloqueará el \textbf{mutex} y aun queda otro objeto que
   sigue bloqueado.
  \item Para ello hay diferentes soluciones:
  \begin{itemize}
    \item Prohibir la copia. Declararemos privado las funciones de copia.
    \item Llevaremos una cuenta de cuantos objetos se han creado y solo
     llamar al destructor cuando no quedan más.
  \end{itemize}
  \item El comportamiento de la copia en las clases RAII más comunes es no
   permitir la copia del recursos en si. Para ello llevan la cuenta de el
   número de referencias que se han hecho, aun así existen otros tipos de
   comportamiento posibles.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 15: Provide access to raw resources in resource-managing
classes}
\label{sec:item15}

\begin{frame}
\frametitle{Item 15: Provide access to raw resources in resource-managing
classes}
\begin{itemize}
  \item Cuando creamos un API las clases están hechas para que interactuaremos
   con ellas, pero hay veces que es necesario permitir al usuario poder acceder
   al recurso \textbf{raw}.
  \item Para ello se puede hacer de dos formas: explicita o implícita.
  \item La forma explicita será devolver el recurso \textbf{raw} mediante la
   llamada a una función.
  \item La forma implícita será sobrecargar el operador de llamada para que
   devuelva el recurso \textbf{raw}.
  \item El problema que puede generar es que asociemos ese recurso \textbf{raw}
   a, por ejemplo, una clase hija del mismo. El programa compilará, pero objeto
   hijo solo tendrá la información del padre, la otra sera indefinida. No hay
   que olvidarse de si liberamos el objeto padre, el objeto hijo se convertirá
   en un \textbf{dangling pointer}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 16: Use the same form in corresponding uses of \textbf{new}
and \textbf{delete}}
\label{sec:item16}

\begin{frame}
\frametitle{Item 16: Use the same form in corresponding uses of \textbf{new}
and \textbf{delete}}
\begin{itemize}
  \item Si usas [] con \textbf{new}, debes usar [] en su correspondiente
   \textbf{delete}. Si no usas [] con \textbf{new}, no debes usar [] cuando
   llames a \textbf{delete}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 17: Store \textbf{new}ed objects in smart pointers in
standalone statements}
\label{sec:item17}

\begin{frame}[allowframebreaks]
\frametitle{Item 17: Store \textbf{new}ed objects in smart pointers in
  standalone statements}
\begin{itemize}
  \item Las funciones pueden requerir el puntero de un objeto en uno de sus
   parametros. Si este es del tipo \textbf{smart\_ptr} podriamos crearlo en la
   misma llamada.
\end{itemize}

\lstinputlisting{assets/listings/item17-1.cpp}

\framebreak

\begin{itemize}
  \item Hacer esto nos lleva a un comportamiento indefinido por el hecho de que
   no hay un orden definido por el compilador.
  \item El compilador puede generar el código de forma errónea ya que el orden
   en que ejecuta las llamadas no siempre es el mismo. Un caso correcto seria:
  \begin{itemize}
    \item Llama a \textbf{priority}.
    \item Ejecuta ``new Widget''.
    \item Llama al constructor de \textbf{shared\_ptr}.
  \end{itemize}
  \item Pero podría darse el caso en que hiciera:
  \begin{itemize}
    \item Ejecuta ``new Widget''.
    \item Llama a \textbf{priority}.
    \item Llama al constructor de \textbf{shared\_ptr}.
  \end{itemize}
  \item Entonces en el caso de que \textbf{priority} causase una excepción se
   generaría una corrupción de memoria.
  \item Por lo tanto, al usar \textbf{smart pointers} la solución optima es
   almacenar en una variable y usarla para llamar a la función.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Designs and declarations}

\subsection{Item 18: Make interfaces easy to use correctly and hard to use
incorrectly}
\label{sec:item18}

\begin{frame}
\frametitle{Item 18: Make interfaces easy to use correctly and hard to use
incorrectly}
\begin{itemize}
  \item Para evitar que el usuario use un valor equivocado en las variables, se
   pueden crear clases o \textbf{structs} que ostentan funciones para crearlos.
   De esa manera no se podrá poner datos erróneos.
  \item Usar \textbf{shared\_ptr} que soportan destructores personalizados. Con
   ello prevenimos problemas con DLLs multiplataforma.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 19: Treat class design as type design}
\label{sec:item19}

\begin{frame}
\frametitle{Item 19: Treat class design as type design}
\begin{itemize}
  \item El diseño de clases es diseño de tipos. Cuando crees un nuevo tipo,
   considera todas las preguntas de este apartado (Véase en el libro).
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 20: Prefer pass-by-reference-to-const to pass-by-value}
\label{sec:item20}

\begin{frame}[allowframebreaks]
\frametitle{Item 20: Prefer pass-by-reference-to-const to pass-by-value}
\begin{itemize}
  \item Cuando usamos \textbf{pass-by-value} con una clases esta tiene que
   llamar al constructor para crearla al inicio de la función y luego al
   destructor al terminar.
  \item Si esta clase es hija de otra o otras clases todas estas tienen que
   llamar a su constructor y a su destructor.
  \item Si alguna de todas estas clases tiene variables no primitivas también
   habrán que crearse y destruirse.
  \item Por ello si usamos \textbf{pass-by-reference-to-const} se evitan todas
   las llamadas a constructores y destructores.

  \framebreak

   \item Otro error común con al usar \textbf{pass-by-value} es usar la clase
   base como argumento. De este modo, al pasar usando \textbf{pass-by-value} una
   clase hija, esta sera \textbf{sliced} y solo se creara una variable con los
   valores de la clase base y no de la hija.
  \item Usa siempre que sea posible \textbf{pass-by-reference-to-const} en vez
   de \textbf{pass-by-value}, evitas tanto problemas de \textbf{slice} y es más
   eficiente.
  \item Esta regla no se aplica a tipos primitivos ni iteradores y objetos de
   la STL. Para ellos es más apropiado usar \textbf{pass-by-value}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 21: Don't try to return a reference when you must return an
object}
\label{sec:item21}

\begin{frame}[allowframebreaks]
\frametitle{Item 21: Don't try to return a reference when you must return an
object}
\begin{itemize}
  \item Usar \textbf{pass-by-reference-to-const} o devolver
   \textbf{const-reference} no es siempre la mejor solución.
  \item Si devolvemos una \textbf{const-reference} de un objeto creado en el
   \textbf{heap} ya que al salir de la función este se destruirá.
  \item Si devolvemos una \textbf{const-reference} de un objeto creado en el
   \textbf{stack} el usuario tendrá que acordarse de llamar a su destructor, aun
   así se pueden dar casos en que sea posible acceder al objeto en cuestión y
   tendremos \textbf{memory leaks}.

  \framebreak

  \item Si devolvemos una \textbf{const-reference} de un objeto \textbf{static}
   tendremos problemas, por ejemplo, si lo usamos para sobrecargar el operador
   de multiplicación, si comparamos dos multiplicaciones que usan la misma
   función, da igual que valores usemos siempre serán igual, debido a que la
   variable \textbf{static} no cambia. También hace que esa función no sea
   \textbf{thread safe}.
   \item Una posible solución es usar el comando \textbf{inline} para devolver
   el objeto como \textbf{const-reference}, de ese modo se creará en el
   \textbf{scope} que deseamos.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 22: Declare data members private}
\label{sec:item22}

\begin{frame}
\frametitle{Item 22: Declare data members private}
\begin{itemize}
  \item Todas las variables de una clase han de ser privadas y que estas puedan
   ser alteradas, si se desea, por funciones \textbf{get} y \textbf{set}.
  \item La finalidad de hacerlas todas privadas sirven para evitar que el
   usuario las use y obligarle a que use dichas funciones que se han creado.
  \item Evitar que el usuario pueda hacer uso de las variables de una clase
   hace que sea posible eliminarlas o modificarlas en un futuro, ya que de ser
   publicas o protegidas, los usuarios deberían modificar su código si estas han
   sido alteradas.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 23: Prefer non-member non-friend functions to member functions}
\label{sec:item23}

\begin{frame}[allowframebreaks]
\frametitle{Item 23: Prefer non-member non-friend functions to member functions}
\begin{itemize}
  \item No siempre todas las funciones para manejar una clase han de
   pertenecer a esta misma. Por ejemplo con la siguiente clase:

  \lstinputlisting{assets/listings/item23-1.cpp}

  \item Crear una función que llame a estas tres seria lo más común, pero la
   pregunta seria si hacerla parte de la clase o una externa que recibe un
   \textbf{WebBrowser} por parámetro y llama a esas funciones.
  \item Hacerla parte de la clase sería lo más obvio y lo que se supone que es
   lo que dicta la programación orientada a objetos, sin embargo no es así,
   sería entenderlo incorrectamente.

  \framebreak

  \item La programación orientada a objetos dicta que la información debe estar
   encapsulada lo máximo posible. Las funciones de una clase o una amiga
   pueden acceder a la información privada, por lo tanto, de querer crear
   nuestro método, es mucho mejor que sea una función externa la que proceda.
  \item Esta función puede pertenecer al mismo \textbf{namespace} que la clase,
   no obstante, deberá localizarse en archivos distintos, es así como funciona
   la STL. El código quedaría de la siguiente forma.

  \framebreak

  \lstinputlisting{assets/listings/item23-2.cpp}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 24: Declare non-member functions when type conversions should
apply to all parameters}
\label{sec:item24}

\begin{frame}
\frametitle{Item 24: Declare non-member functions when type conversions should
apply to all parameters}
\begin{itemize}
  \item En el caso de crear un nuevo tipo de datos, si este solo se usa para
   operar con el mismo no hay problema, pero en el caso de querer operar con
   otros tipos, por ejemplo, con los primitivos es cuando empiezan los problemas.
  \item La solución es declarar el operador que se desea utilizar fuera de la
   clase, debido a que si es parte de la clase solo estos pueden usarlos.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 25: Consider support for a non-throwing swap}
\label{sec:item25}

\begin{frame}
\frametitle{Item 25: Consider support for a non-throwing swap}
\begin{itemize}
  \item Declara la función \textbf{swap} cuando \textbf{std::swap} vaya a ser
   ineficiente. Ten en cuenta de que esta no lance excepciones.
  \item Si ofreces una función miembro \textbf{swap}, también tienes que
   ofrecer una que no sea miembro que llame a la miembro. Para las clases (no
   \textbf{templates}), hazlas parte de \textbf{std::swap} también.
  \item Cuando llamemos a \textbf{swap}, utiliza \textbf{using} de
   \textbf{std::swap} y usa el método sin el \textbf{namespace}, para que así el
   compilador pueda usar la mejor opción de todas.
  \item Esta bien añadir especializaciones nuevas a los \textbf{templates} de
   la STD para tipos creados por el usuario, pero nunca intentes añadir algo
   totalmente nuevo a la STD.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementations}

\subsection{Item 26: Postpone variables definitions as long as possible}
\label{sec:item26}

\begin{frame}
\frametitle{Item 26: Postpone variables definitions as long as possible}
\begin{itemize}
	\item Declarar variables no es gratis ya que supone llamar a su
	 \textbf{constructor} cuando se crea y a su \textbf{destructor} cuando sale
	 fuera del \textbf{scope}.
	\item En todo momento tienes que retrasar la definición de las variables
	 hasta lo más tarde que puedas.
	\item En todo momento has de asignar a la variable con información y no
	 crearla y luego asignarle el valor ya que esto incurriría en un coste de
	 asignación extra después de construirla.
	\item Para bucles es mejor declarar la variables fuera del mismo, solo
	 tienes que recordar que esta variable se destruirá cuando este fuera del
	 \textbf{scope} que posiblemente sea al final de la función.
	\item En el caso que estés en una parte critica del código, es mejor
	 declarar la variable dentro del bucle.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 27: Minimize casting}
\label{sec:item27}

\begin{frame}
\frametitle{Item 27: Minimize casting}
\begin{itemize}
	\item Tipos de cast que existen:
  \begin{itemize}
    \item \textbf{const\_cast} sirve para quitar el \textbf{const} del objeto.
    \item \textbf{dynamic\_cast} se usa para realizar \texttt{safe downcasting}.
     Se realiza en tiempo de ejecución.
    \item \textbf{reinterpret\_cast} esta destinado a \texttt{casts} de bajo
     nivel, por ejemplo, convertir un puntero en un int.
    \item\textbf{static\_cast} pueden ser usados para forzar conversiones
     implícitas o conversiones reversas (un puntero de un objeto base a su
     derivado).
  \end{itemize}
  \item Evitar el uso de \textbf{cast}. Si el diseño lo necesita, intentad usar
   una alternativa sin ellos.
  \item Si es necesario, intentad ocultarlo dentro de una función. Así no hace
   falta que otros usen \textbf{cast} por su cuenta.
  \item Usar los \textbf{casts} de C++ a los de C, debido a que son más
   reconocibles.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 28: Avoid returning ``handles'' to object internals}
\label{sec:item28}

\begin{frame}[allowframebreaks]
\frametitle{Item 28: Avoid returning ``handles'' to object internals}
\begin{itemize}
	\item \textbf{handles} son referencias, punteros y iteradores.
	\item \textbf{Pass-by-reference} es mejor que \textbf{pass-by-value}. Un
	 error seria intentar hacer lo mismo para los objetos que se devuelven en las
	 funciones.
	\item El problema de devolver \textbf{handles} es que se puede acceder a todo
   el objeto y podría llegar al siguiente problema.

	\lstinputlisting{assets/listings/item28-1.cpp}

  \framebreak

  \item Una solución seria hacer:

  \lstinputlisting{assets/listings/item28-2.cpp}

  \item Aunque esto genera otro problema que se llama \textbf{dangling handles}
	 que son \textbf{handles} que referencia a un objeto que ya no existe.

  \framebreak

  \lstinputlisting{assets/listings/item28-3.cpp}

  \item  El problema es que se crea un objeto temporal al llamar a
	 \textbf{BoundingBox} y cuando se termina el \textbf{scope} este se elimina
	 entonces \textbf{pUpperLeft} referencia a un objeto eliminado creando asi un
   \textbf{dangling pointer}.

	\framebreak

  \item Evitad devolver \textbf{handles} de objetos internos de una clase. No
	 devolverlos incrementa la encapsulación, ayuda a los mienbros \textbf{const}
	 actuar como \textbf{const} y minimiza la creación de \textbf{dangling
	 handles}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 29: Strive for exception-safe code.}
\label{sec:item29}

\begin{frame}[allowframebreaks]
\frametitle{Item 29: Strive for exception-safe code.}
\begin{itemize}
	\item Dada la siguente clase:

  \lstinputlisting{assets/listings/item29-1.cpp}

  \framebreak

  \item Y la siguiente función:

  \lstinputlisting{assets/listings/item29-2.cpp}

  \item Podemos ver que de darse una excepción la cosa se puede poner fea.

  \framebreak

  \item Por lo tanto, si buscamos \textbf{exception-safety} hay dos
   aproximaciones:
  \begin{itemize}
    \item \textbf{Leak no resources}, si se da una excepción crean la imagen
     nueva, el \textbf{mutex} jamas se liberará.
    \item \textbf{No permitir que las estructuras se hagan corruptas}, si se da
     una excepción en el constructor, el puntero apuntara a un objeto eliminado
     y el incremento se habrá hecho.
  \end{itemize}
  \item Solucionar el primer problema es fácil, usando RAII visto en el
   item~\ref{sec:item13}, el \textbf{mutex} se liberará cuando salga del
   \textbf{scope} usando los \textbf{locks} del item~\ref{sec:item14}:
  \lstinputlisting{assets/listings/item29-3.cpp}
  \item Menos código mejor, reduce la frequencia de que algo vaya mal.
  \framebreak
  \item Referente al problema segundo problema hay tres formas de solucionar de
   abarcarlo:
  \begin{itemize}
    \item \textbf{La garantia básica}, la función garantiza que de darse un
     excepción todo quedará en un estado valido. Por ejemplo:
     \lstinputlisting{assets/listings/item29-4.cpp}
     De esta forma, solo si se consigue crear el nuevo objeto se cambiara el
      actual.
    \framebreak
    \item \textbf{La garantia fuerte}, la función garantiza que si se da una
     excepción el estado quedará igual. Por ejemplo, si cambiamos la clase para
     que use una estructura con la imagen y el número de cambios:

     \lstinputlisting{assets/listings/item29-5.cpp}

     \framebreak

     Luego, con el uso de \textbf{swap} podemos garantizar la
     \textbf{garantia fuerte}:

     \lstinputlisting{assets/listings/item29-6.cpp}

     De esta forma, solo se usará la nueva imagen y se incrementará si se
     consigue crear el objeto nuevo con la imagen actual, cambiar por la imagen
     nueva y el \textbf{swap} se efectua con éxito.

     \framebreak

    \item \textbf{La garantia nothrow} promete que la función nunca lanzará
     ninguna excepción porqué hacen siempre lo que promete. Esto no quiere decir
     que no haya excepciones, sino que de darse alguna es un problema muy serio.
  \end{itemize}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 30: Understand the ins and outs of inlining.}
\label{sec:item30}

\begin{frame}
\frametitle{Item 30: Understand the ins and outs of inlining.}
\begin{itemize}
	\item \textbf{Inline} es un petición al compilador, no una instrucción.
  \item Sirve para decirle al compilador que reemplace la llamada a la función
   por el código de la misma.
  \item Si se usa demasiado, el código aumentara, lo que lleva a \textbf
   {additional paging}, se reduce el \textbf{instruction cache hit rate} y las
   penalizaciones en rendimiento que acarrea todo eso.
  \item Si se usa para funciones pequeñas muy utilizadas, el código que se
   genera es menor y aumenta el \textbf{instruction cache hit rate}.
  \item Hay dos formas de hacer las funciones \textbf{inline}:
  \begin{itemize}
    \item Declarando la función en la cabecera.
    \item Usando el comando \textbf{inline}.
  \end{itemize}
  \item Hay que tener cuidado con declarar \textbf{inline} las funciones
    \textbf{template} solo por el hecho de que se declaran en las cabeceras.
   Solo hay que hacerlo cuando se crea necesario.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 31: Minimize compilation dependencies between files..}
\label{sec:item31}

\begin{frame}
\frametitle{Item 31: Minimize compilation dependencies between files.}
\begin{itemize}
	\item El compilador necesita saber el tamaño de los objetos que se usan
   en tiempo de compilación. Por lo tanto, algo común es incluir las cabeceras
   debe dichos objetos.
  \item El problema de incluir estas cabeceras es que un cambio en ellas te hara
   tener que recompilar todas las clases donde se usen.
  \item Hay tres simples estrategias de diseño para solucionar este problema:
  \begin{enumerate}
    \item Evitar usar objetos cuando referencias o punteros son suficientes.
    \item Depender en la declaración de las clases y no en la definición de las
     clases.
    \item Usar cabeceras distintas para la declaración y definición de las
     clases. Este se conoce como \textbf{pimpl idiom}. Aun así, el uso de esta
     estrategia reduce la velocidad en ejecución y aumenta el uso de memoria
     por cada objeto que lo use.
  \end{enumerate}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Inheritance and Object-Oriented Design}

\subsection{Item 32: Make sure public inheritance models ``is-a.''}
\label{sec:item32}

\begin{frame}[allowframebreaks]
\frametitle{Item 32: Make sure public inheritance models ``is-a.''}
\begin{itemize}
  \item Todo lo que se aplica a las clases base también se aplica a las clases
   derivadas, porqué toda clase derivada es una clase base.
  \item Por lo tanto, si creasemos la clase pájaro con la función para volar y
   luego definiesemos la clase pingüino que hereda de pájaro de esta forma:
  \lstinputlisting{assets/listings/item32-1.cpp}
  \item Como todo lo que se aplica en pájaro se aplica en pingüino, tendremos
   que estos son capaces de volar, cuando no lo son.
  \framebreak
  \item Una posible solución seria crear una clase ``animal volador'' de la
   siguiente forma:
  \lstinputlisting{assets/listings/item32-2.cpp}
  \item De este modo, los pingüinos no son capaces de volar.
  \item O tambíen se podria sobreescribir el método volar para que devuelva un
   error si intentas hacemos que el pingüino vuele.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 33: Avoid hiding inherited names.}
\label{sec:item33}

\begin{frame}[allowframebreaks]
\frametitle{Item 33: Avoid hiding inherited names.}
\begin{itemize}
  \item Para ponernos en contexto, cuando declaramos una variable, esta tiene
   preferencia antes otras con el mismo nombre fuera del \textbf{scope}, por
   ejemplo:
  \lstinputlisting{assets/listings/item33-1.cpp}
  \item Este mismo comportamiento sucede en la herencia.
  \item Si tenemos las siguientes clases:
  \framebreak
  \lstinputlisting{assets/listings/item33-2.cpp}
  \framebreak
  \item Cuando el compilador vea la llamada a la función mf2 en mf4 tendrá que
   buscar a que función hace referencia. Seguirá el siguiente procedimiento:
   \begin{enumerate}
     \item Buscará en el \textbf{scope} de mf4.
     \item Mirara en la clase Derived.
     \item Por último, ira a la clase Base.
   \end{enumerate}
  \item En el primer lugar donde la encuentre es el que usará.
  \item Entonces, si tenemos las siguientes clases:
  \framebreak
  \lstinputlisting{assets/listings/item33-3.cpp}
  \framebreak
  \item Si ahora ejecutasemos el siguientes código tendriamos que:
  \lstinputlisting{assets/listings/item33-4.cpp}
  \item Para poder solucionar este problema tenemos que darle al compilador
   la información de donde buscar. Esto se consigue usando \textbf{using} de la
   siguiente forma:
  \framebreak
  \lstinputlisting{assets/listings/item33-5.cpp}
  \item En el caso de que solo queramos \textbf{overload} unas pocas funciones
   que compartan nombre, tendremos que usar el comando \textbf{using} para que
   el compilador sea capaz de encontrar la función correcta que no hemos
   \textbf{overload}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 34: Differentiate between inheritance of interface and
 inheritance of implementation.}
\label{sec:item34}

\begin{frame}
\frametitle{Item 34: Differentiate between inheritance of interface and
 inheritance of implementation.}
\begin{itemize}
  \item Heredar de una interfaz es diferente que heredad de una implentación.
   En la herencia pública, las clases derivadas siempre heredan las interfaces
   de las clases base.
  \item Las funciones virtuales puras especifican herencia de interfaz
   solamente.
  \item Funciones virtuales simples (inpuras) especifican herencia de interfaz
   más herencia de una implementación por defecto.
  \item Funciones no-virtuales espeficican herencia de interfaz más herencia de
   una implementación.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 35: Consider alternatives to virtual functions.}
\label{sec:item35}

\begin{frame}[allowframebreaks]
\frametitle{Item 35: Consider alternatives to virtual functions.}
\begin{itemize}
  \item Dada la siguiete clase:
  \lstinputlisting{assets/listings/item35-1.cpp}
  \item Las diferentes estrategias para no usar el convencional diseño orientado
   a objetos serian:
  \framebreak
  \begin{enumerate}
    \item The Template Method Pattern via the Non-Virtual Interface Idiom.
    \begin{itemize}
      \item En este diseño tendremos la función healthValue publica y sin ser
        virtual y la función que hará el trabajo y podrá ser sobrecargada será
        una privada llamada doHealthValue como podemos ver en el siguiente
        código:
        \lstinputlisting{assets/listings/item35-2.cpp}
        \item En este diseño ganamos la habilidad de poder hacer algo antes y
         después de llamar a la función virtual.
        \item Aunque podamos cambiar el comportamiento de doHealthValue, la
         clase base se reserva el derecho de llamar a la clase virtual.
    \end{itemize}
    \framebreak
    \item The Strategy Pattern via Function Pointers.
    \begin{itemize}
      \item La idea es usar punteros a funciones que tengan el comportamiento
       que se desea, por ejemplo:
      \lstinputlisting{assets/listings/item35-3.cpp}
      \framebreak
      \item Esto nos ofrece la flexibilidad para:
        \item[1.] Diferentes instancias del mismo objeto pueden usar funciones
         distintas:
        \lstinputlisting{assets/listings/item35-4.cpp}
        \item[2.] La función puede cambiarse en tiempo de ejecución.
    \end{itemize}
    \framebreak
    \item The Strategy Pattern via stl::function.
    \begin{itemize}
      \item Para este diseño usaremos el mismo código que en punto anterior
       cambiando el \textbf{typedef} por:
       \lstinputlisting{assets/listings/item35-5.cpp}
      \item Ahora usamos stl::function en vez de un puntero normal a una
       función.
      \framebreak
      \item Por lo tanto, si tenemos estas clases:
      \lstinputlisting{assets/listings/item35-6.cpp}
      \item Nos permite poder hacer lo siguiente:
      \lstinputlisting{assets/listings/item35-7.cpp}
      \item stl::function nos da mucha versatibilidad. Podemos pasar una
       función, la función de un objeto o usar std::bind.
      \item std::bind lo que hace es ``anidar'' la funcion \texttt{health} del
       objeto \texttt{currentLevel} para hacer el calculo.
    \end{itemize}
    \framebreak
    \item The ``Classic'' Strategy Pattern.
    \begin{itemize}
      \item Sino deseamos usar funcionalidades de C++ y quedarnos con un enfoque
      clásico, podemos hacer que el calculo sea una clase base la cual pueda
      ser heredada por otras que cambien la función. Por ejemplo:
      \framebreak
      \lstinputlisting{assets/listings/item35-8.cpp}
    \end{itemize}
  \end{enumerate}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 36: Never redefine an inherited non-virtual function.}
\label{sec:item36}

\begin{frame}
\frametitle{Item 36: Never redefine an inherited non-virtual function.}
\begin{itemize}
  \item Si una clase derivada usa el mismo nombre de una función base que no es
   virtual, esta ocultara la de la clase base y se llamará a la que esta en la
   derivada:
  \lstinputlisting{assets/listings/item36-1.cpp}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 37: Never redefine a function’s inherited default
parameter value.}
\label{sec:item37}

\begin{frame}
\frametitle{Item 37: Never redefine a function’s inherited default
parameter value.}
\begin{itemize}
  \item Las funciones virtuales son \textbf{dynamically bound}, pero los
   parametros por defecto son \textbf{statically bound}.
  \item Si sobrecargamos una función con un parametros por defecto de la base y
   cambiamos ese valor en la derivada, el valor por defecto a usar siempre será
   el de la clase base:
  \lstinputlisting{assets/listings/item37-1.cpp}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 38: Model “has-a” or “is-implemented-in-terms- of” through
 composition.}
\label{sec:item38}

\begin{frame}
\frametitle{Item 38: Model “has-a” or “is-implemented-in-terms- of” through
 composition.}
\begin{itemize}
  \item \textbf{Composition} es la relación entre los tipos de un objeto que
   surgen cuando los objetos de un tipo contienen objetos de otro.
  \item En el dominio de la aplicación, \textbf{composition} se traduce a
   \textbf{has-a}.
  \item En el dominio de la implementación, se refiere a
   \textbf{is-implemented-in-terms-of}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 39: Use private inheritance judiciously.}
\label{sec:item39}

\begin{frame}
\frametitle{Item 39: Use private inheritance judiciously.}
\begin{itemize}
  \item Reglas de la herencia privada:
  \begin{enumerate}
    \item El compilador no convertirá la clase derivada a la clase base.
    \item Todo lo heredado se convierte en privado pese a que en la clase base
     sea \textbf{protected} o \textbf{public}.
  \end{enumerate}
  \item La herencia privada es \textbf{is-implemented-in-terms-of}, por lo que
   solo se hereda la implementación; las interfaces deben ser ignoradas. Si D
   hereda privadamente de B quiere decir que los objetos de D se implementan
   como B, nada más.
  \item Puede usarse para conseguir la \textbf{empty base optimization} (EBO).
  Consiste en heredad de forma privada de una clase vacia. Esto hace, en la
  mayoría de compiladores, a que el objeto ocupe la memoria que tiene y que no
  se añada ningun \textbf{padding}. Por ejemplo:

  \lstinputlisting{assets/listings/item39-1.cpp}

  Tendremos que sizeof(HoldsAnInt) == sizeof(int).
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Item 40: Use mutiple inheritance judiciously.}
\label{sec:item40}

\begin{frame}[allowframebreaks]
\frametitle{Item 40: Use mutiple inheritance judiciously.}
\begin{itemize}
  \item Uno de los principales problemas con la multiherencia es que podemos
   heredar de dos clases que implementan una función con el mismo nombre, lo que
   genera un error de ambigüedad.
  \item También podemos encontrarnos con el famoso problema
   ``deadly MI diamond'':

  \lstinputlisting{assets/listings/item40-1.cpp}

  \item Una forma de solucionar esto es usando herencia \textbf{virtual}. Puede
   parecer que siempre que usemos herencia pública debamos de usar herencia
   pública virtual.
  \item La herencia virtual no es gratuita, esta requiere un trabajo extra por
   parte del compilador. Como resultado tendremos clases que ocupan más y son
   más lentas que si no usasen herencia virtual.

  \framebreak

  \item Si usamos herencia virtual hay que tener en cuenta que el responsable
   de inicializar la clase base recae sobre última clase derivada de la
   herarquia. Por lo que si se añadiese otra clase derivada, esta se deberia
   de encargar de inicializar su base virtual (tanto directa como indirecta).
  \item Por lo tanto, se debe usar herencia virtual solamente cuando se
   necesario y de hacerlo intentar hacerlo con clases que no contengan datos.
   Así es como funcionan las \textbf{interfaces} en Java y .NET.

  \framebreak

  \item Aun así, la herencia multiple es util para un uso en concreto. Podemos
   heredar de una interfaz pública y heredad la implementación de forma privada
   de otra clase. Por ejemplo, si tienemos una interfaz IPerson y una clase
   PersonInfo que provee de lo necesario para poder crear IPerson como podemos
   ver a continuación:

  \lstinputlisting{assets/listings/item40-2.cpp}

  \framebreak

  \item Por lo que podremos crear una clase CPerson que implemente la interfaz
   IPerson usando PersonInfo:

   \lstinputlisting{assets/listings/item40-3.cpp}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
